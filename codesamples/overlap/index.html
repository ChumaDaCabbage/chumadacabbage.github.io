<!--__________________________________________________________________________________________________________-->
<!--________________________________________OVERLAP CODE SAMPLES PAGE_________________________________________-->
<!--__________________________________________________________________________________________________________-->
<!DOCTYPE html>
<html> 
  <!-- ---------------------------------------------------------------------------- -->
  <!-- ------------------------------------Head------------------------------------ -->
  <!-- ---------------------------------------------------------------------------- -->
  <head>
    <!-- Connect javascript functions and setup page-->
    <script type="text/javascript" src="/functions.js"></script>
    <script> window.addEventListener('load', function() {loadPageDefualts();}); </script>

    <title>Evan Gray | Code Samples</title>

    <!-- Link to the external stylesheets -->
    <link rel="stylesheet" type="text/css" href="/codesamples/codeSampleStyles.css">

    <!-- Link to the google code-prettify library styles -->
    <script type="text/javascript" src="/googlePrettify/prettify.js"></script>

    <!-- Load code snippets on page load and run prettify on them -->
    <script>  window.addEventListener('load', function() {loadCode('overlap.cpp');}); </script>
  </head>

  <!-- ---------------------------------------------------------------------------- -->
  <!-- ------------------------------------Body------------------------------------ -->
  <!-- ---------------------------------------------------------------------------- -->

  <body>
    <!-- ~~~~~~~~~~~Tabs~~~~~~~~~~ -->
    <div class = "tabrow">
      <button class = "tabinactive" onclick = "window.location.href = '/codesamples/opengl-computeshader'">
        <div class = "codeTitle">
          <h1>OpenGL Compute Shaders</h1>
        </div>
      </button>
      <button class="tab" onclick = "location.reload()">
        <div class = "codeTitle">
          <h1>Overlapping Rectangles</h1>
        </div>
      </button>
      <button class="tabinactive" onclick = "window.location.href = '/codesamples/vulkan-computepipeline'">
        <div class = "codeTitle">
          <h1>Vulkan Compute Pipeline</h1>
        </div>
      </button>
      <button class = "tabinactive" onclick = "window.location.href = '/codesamples/bst-map'">
        <div class = "codeTitle">
          <h1>Binary Search Tree Map</h1>
        </div>
      </button>
    </div>
    <hr style="width: 96.9%; margin-top: 0; margin-bottom: -0.2vh; margin-left: 1.5vw;">

    <!-- ~~~~~~~~~~~Code Sample~~~~~~~~~~~ -->
    <div class = "codeSnippet" id="codeSnippet">
      <div class = "codeLoadingZone" id="overlap.cpp">
        <!-- Code snippet will get autoloaded here :D -->
      </div>
      <div class = "codeDescription">
<h2>Overview:</h2>
<p>This code determines how many cells in a grid are covered by a specific number of overlapping rectangles. This is solved using a sweep line algorithm to avoid processing every cell individually. In given test cases the grid can be as large as 10^9*10^9, and contain up to 10^5 rectangles. The output is a map indicating how many cells are covered by exactly ùê∂ rectangles (modulo 7001 to prevent overflow).</p>


<h2>Showcase Purpose:</h2>
<p>This code demonstrates the use of STL data structures in solving a computational geometry problem. It highlights my ability to combine algorithmic design with STL containers for optimal performance.</p>
<p>By focusing on efficiency, this example showcases my skills in leveraging STL to write high quality, performant C++ code.</p>


<h2>Details:</h2>
<p>Input Processing:</p>
<div class="inset">
<p>The code begins by reading rectangle data from a file. Each rectangle is defined by its top-left corner (<code>x‚ÇÅ, y‚ÇÅ</code>) and bottom-right corner (<code>x‚ÇÇ, y‚ÇÇ</code>). For each rectangle, two events are created:</p>
<ul><li>A start event at <code>y‚ÇÅ</code>, for a rectangle covering the x-range [<code>x‚ÇÅ, x‚ÇÇ</code>]</li>
<li>An end event at <code>y‚ÇÇ + 1</code>, for a rectangle un-covering the x-range [<code>x‚ÇÅ, x‚ÇÇ</code>]</li></ul>
<p>These events are stored in a multimap, which automatically sorts them by their y-coordinates. This ensures that the sweep line processes the events in the correct order, moving from top to bottom.</p>
</div>
<p>Sweep Line Algorithm:</p>
<div class="inset">
<p>The algorithm uses a "sweep line" to move down the grid and process events. It keeps track of overlap counts dynamically, avoiding the need to check every cell.</p>
<p>Tracking Overlaps:</p>
<div class="insetDeep"><p>A data structure called <code>LineData</code> keeps track of the number of overlaps at each x-coordinate using a vector. Additionally, it uses a hash map to count how many x-coordinates share the same overlap value (e.g., "10 x-coordinates have an overlap count of 1").</p></div>
<p>Processing Events:</p>
<div><ul><li>For a start event, the overlap count for all x-coordinates in the range [<code>x‚ÇÅ, x‚ÇÇ</code>] is incremented</li>
<li>For an end event, the overlap count for the same range is decremented</li>
<li>After adjusting overlap counts, the map is updated to reflect the new distribution of overlap counts</li></ul></div> 
<p>Calculating Area Contributions:</p>
<div class="insetDeep"><p>Between events, the algorithm calculates the total area contributed by each overlap count. This is done by multiplying the number of x-coordinates with a specific overlap count by the vertical distance (difference in y-coordinates) between consecutive events. These contributions are added to the final result map, with all calculations performed modulo 7001 to prevent overflow.</p></div> 
<p>Efficiency:</p>
<div class="insetDeep"><p>The algorithm processes only the edges of rectangles (start and end events) and updates overlap counts directly, making it efficient even for large inputs.</p></div> 
</div>
<h3>Output:</h3>
<div class="inset"><p>The final output is a map where the keys are overlap counts and the values indicate the total area covered by those counts, modulo 7001. (e.g., 500 cells with 0 overlaps, 230 cells with 1 overlap, ect.) This approach ensures the solution is scalable and avoids unnecessary computations.</p></div>
      </div>
    </div>
  </body>
</html>
